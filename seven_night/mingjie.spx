import (
    "fmt"
    "math"
    "math/rand"
    "time"
)

// Point 表示二维坐标点
type PointM struct {
    X, Y float64
}

// MovementConfig 运动配置
type MovementConfigM struct {
    MinSpeed      float64
    MaxSpeed      float64
    JumpProb      float64 // 跳跃概率
    DirectionProb float64 // 改变方向概率
    BaseY         float64 // 基础Y坐标（地面）
    MaxJumpHeight float64
    Gravity       float64
}

// DefaultConfig 默认配置
func DefaultConfigM() *MovementConfigM {
    return &MovementConfigM{
        MinSpeed:      10.0,
        MaxSpeed:      25.0,
        JumpProb:      0.1, // 每帧2%的概率跳跃
        DirectionProb: 0.25, // 15%的概率改变方向
        BaseY:         -80.0,
        MaxJumpHeight: 100.0,
        Gravity:       9.8,
    }
}

// RandomMovementGenerator 随机运动生成器
type RandomMovementGeneratorM struct {
    config     *MovementConfigM
    currentPos Point
    velocity   float64
    direction  int // 1: 右, -1: 左, 0: 停止
    jumpCount  int
    lastChange int
}

// NewRandomMovementGenerator 创建新的运动生成器
func NewRandomMovementGeneratorM(initialX, initialY float64) *RandomMovementGeneratorM {
    cfg := DefaultConfigM()
    return &RandomMovementGeneratorM{
        config:     cfg,
        currentPos: Point{X: initialX, Y: initialY},
        velocity:   cfg.MinSpeed + rand.Float64()*(cfg.MaxSpeed-cfg.MinSpeed),
        direction:  1,
    }
}

// GenerateMovement 生成下一帧的移动
func (rmg *RandomMovementGeneratorM) GenerateMovement(dt float64) Point {
    // 随机改变方向和速度
    rmg.maybeChangeDirection()

    // 更新水平位置
    rmg.currentPos.X += rmg.velocity * float64(rmg.direction) * dt

    // 边界检测
    if rmg.currentPos.X < -200 {
        rmg.currentPos.X = -200
        rmg.direction = 1
    }

	 if rmg.currentPos.X > 200 {
        rmg.currentPos.X = 200
        rmg.direction = -1
    }

    // 随机跳跃
    // if rand.Float64() < rmg.config.JumpProb {
    //  rmg.executeJump()
    // }

    // 地面检测
    if rmg.currentPos.Y > rmg.config.BaseY {
        rmg.currentPos.Y = rmg.config.BaseY
    }

    return rmg.currentPos
}

// maybeChangeDirection 随机改变移动方向和速度
func (rmg *RandomMovementGeneratorM) maybeChangeDirection() {
    if rand.Float64() < rmg.config.DirectionProb {
        rmg.direction = rmg.generateRandomDirection()
    }

    // 随机改变速度
    if rand.Float64() < 0.2 { // 20%的概率改变速度
        rmg.velocity = rmg.config.MinSpeed + rand.Float64()*(rmg.config.MaxSpeed-rmg.config.MinSpeed)
    }
}

// generateRandomDirection 生成随机方向
func (rmg *RandomMovementGeneratorM) generateRandomDirection() int {
    // 随机选择方向：左、右或暂停
    r := rand.Intn(100)
    switch {
    case r < 40: // 40%概率向右
        return 1
    case r < 80: // 40%概率向左
        return -1
    default: // 20%概率暂停
        return 0
    }
}

// executeJump 执行跳跃动作
func (rmg *RandomMovementGeneratorM) executeJump() {
    // 随机跳跃高度
    jumpHeight := rmg.config.MaxJumpHeight * (0.3 + 0.7*rand.Float64())
    // 简单模拟跳跃，直接更新Y值
    rmg.currentPos.Y -= jumpHeight
    if rmg.currentPos.Y < rmg.config.BaseY-jumpHeight {
        rmg.currentPos.Y = rmg.config.BaseY - jumpHeight
    }
}

// GenerateJumpTrajectory 生成跳跃轨迹
func (rmg *RandomMovementGeneratorM) GenerateJumpTrajectory(startX, startY float64, frames int) []Point {
    trajectory := make([]Point, frames)
    
    // 使用抛物线模拟跳跃 - 修正后的公式
    peakHeight := rmg.config.MaxJumpHeight * (0.7 + 0.3*rand.Float64())
    
    for i := 0; i < frames; i++ {
        t := float64(i) / float64(frames-1) // t从0到1
        
        // 标准抛物线公式: y = -4h(t-0.5)² + h
        // 这样在t=0和t=1时y=0，在t=0.5时y=peakHeight
        jumpOffset := 4 * peakHeight * math.Pow(t-0.5, 2) - peakHeight
        
        x := startX + 2.0*t // 轻微的水平移动
        y := startY - jumpOffset // 向上跳跃（Y值减小）
        
        // 落地检测：确保不会穿透地面
        // 假设地面在 config.BaseY，角色不能跳到地面以下
        if y < rmg.config.BaseY {
            y = rmg.config.BaseY
        }
        
        trajectory[i] = Point{
            X: x,
            Y: y,
        }
    }
    
    return trajectory
}

// 生成一个复杂运动序列，包含随机移动和跳跃
func generateComplexMovementSequenceM(start Point, totalFrames int) []Point {
    positions := make([]Point, 0, totalFrames)
    movementGen := NewRandomMovementGeneratorM(start.X, start.Y)

    i := 0
    for i < totalFrames {
        // 生成随机移动
        pos := movementGen.GenerateMovement(1.0 / 20.0)
        positions = append(positions, pos)

        // 随机插入跳跃轨迹
        if rand.Float64() < 0.08 { // 8%的概率插入跳跃序列
            jumpFrames := 10 + rand.Intn(20) // 10-30帧的跳跃动作
            if rand.Float64() < 0.1 { // 10%的概率较大幅度跳跃
                jumpTrajectory := movementGen.GenerateJumpTrajectory(pos.X, pos.Y, jumpFrames)
                for j := 0; j < len(jumpTrajectory) && i < totalFrames; j++ {
                    positions = append(positions, jumpTrajectory[j])
                    i++
                }
                continue // 跳过本帧正常移动
            }
        }
        i++
    }
    return positions
}

onStart => {
	// setSize 1
	// animate "左右挥砍", true
	// setRotationStyle Normal
	// wait 10
	// stopAnimation "左右挥砍"
	hide
	onMsg "start_case1", => {
		wait 3
		show
		setLayer Front
		setXYpos 50, -90
		setCostume "跳剑1"
		wait 1
		animate "飞下砍"
		wait 1

		start := Point{50,-90}
		print("start positions:", start)
		points := generateComplexMovementSequenceM(start, 300)
    	for i := 0; i < 300; i++ {
			animate "fight", true
			
			newPos := points[i]
			
			fmt.Printf("帧 %d: (%.2f, %.2f)\n", i, newPos.X, newPos.Y)
			glide newPos.X, newPos.Y, 0.05
			// 模拟高帧率
			// time.Sleep(time.Millisecond * 50)
    	}

		stopAnimation "fight"
		setXYpos xpos-40, ypos+5
		setCostume "定格1"
		//stopAnimation "左右挥砍"
		wait 1
		hide
		//broadcast "start_case1"
	}
}
